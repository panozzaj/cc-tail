#!/usr/bin/env bash
# Tail thinking from a Claude Code session

# Don't use set -e as jq -e returns non-zero when no match

usage() {
    cat <<EOF
cc-tail - Tail thinking from a Claude Code session

USAGE:
    cc-tail [OPTIONS] [session-id] [project-path]

OPTIONS:
    --no-follow    Print existing content and exit (default: follow live)
    --tools        Also show tool calls (Edit, Bash, Write, etc.)
    --tool-output  Also show tool results/outputs
    --output       Also show Claude's text responses
    --user         Also show user messages
    --all          Show everything (thinking + tools + tool-output + output + user)
    -h, --help     Show this help message

ARGUMENTS:
    session-id    UUID of the session (from /status). If omitted, uses most recent.
    project-path  Path to the project. If omitted, uses current directory.

EXAMPLES:
    cc-tail                          # follow live thinking
    cc-tail --no-follow              # print existing and exit
    cc-tail --tools                  # include tool calls
    cc-tail --all                    # show everything
EOF
    exit 0
}

NO_FOLLOW=false
SHOW_TOOLS=false
SHOW_TOOL_OUTPUT=false
SHOW_OUTPUT=false
SHOW_USER=false

# Parse flags
while [[ "$1" == -* ]]; do
    case "$1" in
        --no-follow)
            NO_FOLLOW=true
            shift
            ;;
        --tools)
            SHOW_TOOLS=true
            shift
            ;;
        --tool-output)
            SHOW_TOOL_OUTPUT=true
            shift
            ;;
        --output)
            SHOW_OUTPUT=true
            shift
            ;;
        --user)
            SHOW_USER=true
            shift
            ;;
        --all)
            SHOW_TOOLS=true
            SHOW_TOOL_OUTPUT=true
            SHOW_OUTPUT=true
            SHOW_USER=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo "Unknown flag: $1" >&2
            echo "Use --help for usage information" >&2
            exit 1
            ;;
    esac
done

CLAUDE_DIR="$HOME/.claude/projects"

# Colors - use $'...' for actual escape chars
RESET=$'\033[0m'
DIM=$'\033[2m'
BOLD=$'\033[1m'
YELLOW=$'\033[33m'
GREEN=$'\033[32m'
RED=$'\033[31m'
CYAN=$'\033[36m'
WHITE=$'\033[37m'
MAGENTA=$'\033[35m'

# Secondary content (tool output, descriptions) - readable but muted
SECONDARY=$'\033[38;2;160;160;160m'

# Thinking blocks - rotating blue/gray shades
BLUE1=$'\033[38;2;100;149;237m'  # cornflower blue
BLUE2=$'\033[38;2;119;136;153m'  # light slate gray
BLUE3=$'\033[38;2;135;160;190m'  # steel blue-ish
BLUE4=$'\033[38;2;95;130;160m'   # darker steel

# Convert path to Claude's directory format (slashes become dashes)
path_to_claude_dir() {
    echo "${1//\//-}"
}

# Format timestamp
format_time() {
    local timestamp="$1"
    if [[ -n "$timestamp" ]]; then
        date -j -f "%Y-%m-%dT%H:%M:%S" "${timestamp%%.*}" "+%H:%M:%S" 2>/dev/null || echo "$timestamp"
    else
        echo "??:??:??"
    fi
}

# Word wrap text to terminal width
wrap_text() {
    local width="${COLUMNS:-$(tput cols 2>/dev/null || echo 80)}"
    fold -s -w "$width"
}

# Highlight backticked content in the text
highlight_backticks() {
    local return_color="$1"
    sed -E "s/\`([^\`]+)\`/${YELLOW}\`\1\`${return_color}/g"
}

# Format thinking output with subtle blue colors
format_thinking() {
    local text="$1"
    local counter="$2"

    local colors=("$BLUE1" "$BLUE2" "$BLUE3" "$BLUE4")
    local color_idx=$((counter % 4))
    local block_color="${colors[$color_idx]}"

    echo "$text" | wrap_text | highlight_backticks "$block_color" | while IFS= read -r line; do
        echo "${block_color}${line}${RESET}"
    done
}

# Format a diff with context
format_diff() {
    local old_string="$1"
    local new_string="$2"

    # Write to temp files for diff
    local old_file=$(mktemp)
    local new_file=$(mktemp)
    echo "$old_string" > "$old_file"
    echo "$new_string" > "$new_file"

    # Use diff -u for unified diff, then colorize
    diff -u "$old_file" "$new_file" 2>/dev/null | tail -n +3 | while IFS= read -r line; do
        if [[ "$line" == -* ]]; then
            echo "${RED}${line}${RESET}"
        elif [[ "$line" == +* ]]; then
            echo "${GREEN}${line}${RESET}"
        elif [[ "$line" == @* ]]; then
            echo "${DIM}${line}${RESET}"
        else
            echo "${DIM}  ${line}${RESET}"
        fi
    done

    rm -f "$old_file" "$new_file"
}

# Format tool call output
format_tool_call() {
    local tool_name="$1"
    local tool_input="$2"
    local timestamp="$3"

    echo ""
    echo "${DIM}─── ${CYAN}${tool_name}${RESET} ${DIM}@ $(format_time "$timestamp") ───${RESET}"

    case "$tool_name" in
        Edit)
            local file_path=$(echo "$tool_input" | jq -r '.file_path // empty')
            local old_string=$(echo "$tool_input" | jq -r '.old_string // empty')
            local new_string=$(echo "$tool_input" | jq -r '.new_string // empty')
            local replace_all=$(echo "$tool_input" | jq -r '.replace_all // false')

            local short_path="${file_path/#$HOME/~}"
            echo "${BOLD}${short_path}${RESET}"
            [[ "$replace_all" == "true" ]] && echo "${DIM}(replace all)${RESET}"
            format_diff "$old_string" "$new_string"
            ;;
        Write)
            local file_path=$(echo "$tool_input" | jq -r '.file_path // empty')
            local content=$(echo "$tool_input" | jq -r '.content // empty')
            local short_path="${file_path/#$HOME/~}"
            local line_count=$(echo "$content" | wc -l | tr -d ' ')
            echo "${BOLD}${short_path}${RESET} ${DIM}(${line_count} lines)${RESET}"
            echo "$content" | head -5 | while IFS= read -r line; do
                echo "${GREEN}+ ${line}${RESET}"
            done
            [[ $line_count -gt 5 ]] && echo "${DIM}  ... ($((line_count - 5)) more lines)${RESET}"
            ;;
        Bash)
            local command=$(echo "$tool_input" | jq -r '.command // empty')
            local description=$(echo "$tool_input" | jq -r '.description // empty')
            [[ -n "$description" ]] && echo "${SECONDARY}# ${description}${RESET}"
            echo "${YELLOW}\$ ${command}${RESET}"
            ;;
        Read)
            local file_path=$(echo "$tool_input" | jq -r '.file_path // empty')
            echo "${DIM}reading${RESET} ${BOLD}${file_path/#$HOME/~}${RESET}"
            ;;
        Glob)
            local pattern=$(echo "$tool_input" | jq -r '.pattern // empty')
            local path=$(echo "$tool_input" | jq -r '.path // "."')
            echo "${DIM}glob${RESET} ${YELLOW}${pattern}${RESET} ${DIM}in${RESET} ${path}"
            ;;
        Grep)
            local pattern=$(echo "$tool_input" | jq -r '.pattern // empty')
            local path=$(echo "$tool_input" | jq -r '.path // "."')
            echo "${DIM}grep${RESET} ${YELLOW}${pattern}${RESET} ${DIM}in${RESET} ${path}"
            ;;
        Task)
            local description=$(echo "$tool_input" | jq -r '.description // empty')
            local subagent_type=$(echo "$tool_input" | jq -r '.subagent_type // empty')
            echo "${MAGENTA}${subagent_type}${RESET}: ${description}"
            ;;
        *)
            echo "$tool_input" | jq -C '.' 2>/dev/null || echo "$tool_input"
            ;;
    esac
}

# Format tool result/output
format_tool_result() {
    local content="$1"
    local tool_use_result="$2"

    # Get output from toolUseResult if available
    local output=$(echo "$tool_use_result" | jq -r '.stdout // empty' 2>/dev/null)
    [[ -z "$output" || "$output" == "null" ]] && output="$content"
    local stderr=$(echo "$tool_use_result" | jq -r '.stderr // empty' 2>/dev/null)

    [[ -z "$output" && -z "$stderr" ]] && return

    echo "${SECONDARY}    ↳${RESET}"

    # Truncate long output
    local max_lines=15
    if [[ -n "$output" && "$output" != "null" ]]; then
        local line_count=$(echo "$output" | wc -l | tr -d ' ')
        echo "$output" | head -$max_lines | while IFS= read -r line; do
            echo "${SECONDARY}    ${line}${RESET}"
        done
        [[ $line_count -gt $max_lines ]] && echo "${DIM}    ... ($((line_count - max_lines)) more lines)${RESET}"
    fi

    [[ -n "$stderr" && "$stderr" != "null" ]] && echo "${RED}    stderr: ${stderr:0:200}${RESET}"
}

# Format text response
format_response() {
    local text="$1"
    local timestamp="$2"

    echo ""
    echo "${DIM}─── ${WHITE}response${RESET} ${DIM}@ $(format_time "$timestamp") ───${RESET}"
    echo "$text" | wrap_text | while IFS= read -r line; do
        echo "${WHITE}${line}${RESET}"
    done
}

# Format user message
format_user_message() {
    local text="$1"
    local timestamp="$2"

    echo ""
    echo "${DIM}─── ${MAGENTA}user${RESET} ${DIM}@ $(format_time "$timestamp") ───${RESET}"
    echo "$text" | wrap_text | while IFS= read -r line; do
        echo "${MAGENTA}${line}${RESET}"
    done
}

# Find session file
if [[ -n "$1" ]]; then
    SESSION_ID="$1"
    PROJECT_PATH="${2:-$(pwd)}"
    PROJECT_DIR="$CLAUDE_DIR/$(path_to_claude_dir "$PROJECT_PATH")"
    SESSION_FILE="$PROJECT_DIR/$SESSION_ID.jsonl"
else
    PROJECT_DIR="$CLAUDE_DIR/$(path_to_claude_dir "$(pwd)")"
    if [[ ! -d "$PROJECT_DIR" ]]; then
        echo "${BOLD}No Claude sessions found for $(pwd)${RESET}" >&2
        echo "${DIM}Project dir would be: $PROJECT_DIR${RESET}" >&2
        exit 1
    fi
    SESSION_FILE=$(ls -t "$PROJECT_DIR"/*.jsonl 2>/dev/null | head -1)
    SESSION_ID=$(basename "$SESSION_FILE" .jsonl)
fi

if [[ ! -f "$SESSION_FILE" ]]; then
    echo "${BOLD}Session file not found: $SESSION_FILE${RESET}" >&2
    exit 1
fi

# Build mode description
mode_desc="thinking"
[[ "$SHOW_TOOLS" == true ]] && mode_desc="$mode_desc + tools"
[[ "$SHOW_TOOL_OUTPUT" == true ]] && mode_desc="$mode_desc + tool-output"
[[ "$SHOW_OUTPUT" == true ]] && mode_desc="$mode_desc + output"
[[ "$SHOW_USER" == true ]] && mode_desc="$mode_desc + user"

# Print header
if [[ "$NO_FOLLOW" == true ]]; then
    echo "${BOLD}Showing${RESET} session: ${CYAN}$SESSION_ID${RESET}"
else
    echo "${BOLD}Following${RESET} session: ${CYAN}$SESSION_ID${RESET}"
fi
echo "$mode_desc"
echo "${DIM}$SESSION_FILE${RESET}"
echo "${DIM}────────────────────────────────────────${RESET}"

counter=0

# Choose between tail -f (follow) or cat (dump existing)
if [[ "$NO_FOLLOW" == true ]]; then
    read_cmd="cat"
else
    read_cmd="tail -f"
fi

# Process content
$read_cmd "$SESSION_FILE" | while read -r line; do
    timestamp=$(echo "$line" | jq -r '.timestamp // empty' 2>/dev/null)

    # User messages
    if [[ "$SHOW_USER" == true ]]; then
        if echo "$line" | jq -e 'select(.type == "user")' >/dev/null 2>&1; then
            # Content can be a string or an array
            content_type=$(echo "$line" | jq -r '.message.content | type' 2>/dev/null)
            if [[ "$content_type" == "string" ]]; then
                user_content=$(echo "$line" | jq -r '.message.content // empty' 2>/dev/null)
            elif [[ "$content_type" == "array" ]]; then
                # Extract text from array items
                user_content=$(echo "$line" | jq -r '.message.content[] | select(.type == "text") | .text // empty' 2>/dev/null)
            fi
            if [[ -n "$user_content" && "$user_content" != "null" ]]; then
                format_user_message "$user_content" "$timestamp"
            fi
        fi
    fi

    # Thinking
    if echo "$line" | jq -e '.message.content[]? | select(.type == "thinking")' >/dev/null 2>&1; then
        thinking=$(echo "$line" | jq -r '.message.content[] | select(.type == "thinking") | .thinking' 2>/dev/null)
        if [[ -n "$thinking" && "$thinking" != "null" ]]; then
            echo ""
            echo "${DIM}─── ${YELLOW}thinking${RESET} ${DIM}@ $(format_time "$timestamp") ───${RESET}"
            format_thinking "$thinking" "$counter"
            ((counter++)) || true
        fi
    fi

    # Tool calls
    if [[ "$SHOW_TOOLS" == true ]]; then
        if echo "$line" | jq -e '.message.content[]? | select(.type == "tool_use")' >/dev/null 2>&1; then
            echo "$line" | jq -c '.message.content[] | select(.type == "tool_use")' 2>/dev/null | while read -r tool_call; do
                tool_name=$(echo "$tool_call" | jq -r '.name // empty')
                tool_input=$(echo "$tool_call" | jq -c '.input // {}')
                format_tool_call "$tool_name" "$tool_input" "$timestamp"
            done
        fi
    fi

    # Tool results/output
    if [[ "$SHOW_TOOL_OUTPUT" == true ]]; then
        if echo "$line" | jq -e '.message.content[]? | select(.type == "tool_result")' >/dev/null 2>&1; then
            content=$(echo "$line" | jq -r '.message.content[] | select(.type == "tool_result") | .content // empty' 2>/dev/null)
            tool_use_result=$(echo "$line" | jq -c '.toolUseResult // {}' 2>/dev/null)
            format_tool_result "$content" "$tool_use_result"
        fi
    fi

    # Text responses
    if [[ "$SHOW_OUTPUT" == true ]]; then
        if echo "$line" | jq -e '.message.content[]? | select(.type == "text")' >/dev/null 2>&1; then
            text=$(echo "$line" | jq -r '.message.content[] | select(.type == "text") | .text // empty' 2>/dev/null)
            if [[ -n "$text" && "$text" != "null" ]]; then
                format_response "$text" "$timestamp"
            fi
        fi
    fi
done
